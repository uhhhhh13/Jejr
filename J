-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local VirtualInputManager = game:GetService("VirtualInputManager")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local Stats = game:GetService("Stats")
local GuiService = game:GetService("GuiService")

-- Local Player Variables
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Hotbar = PlayerGui:WaitForChild("Hotbar")
local ParryCD = Hotbar.Block.UIGradient
local AbilityCD = Hotbar.Ability.UIGradient

-- Original Variables (from provided code)
local Phantom = false
local Tornado_Time = tick()
local Last_Input = UserInputService:GetLastInputType()
local Vector2_Mouse_Location = nil
local Grab_Parry = nil
local Parry_Remote = true
local Parry_Key = nil
local Parry_Arg = nil
local Speed_Divisor_Multiplier = 1.1
local LobbyAP_Speed_Divisor_Multiplier = 1.1
local firstParryFired = false
local ParryThreshold = 2.5
local firstParryType = 'F_Key'
local Previous_Positions = {}
local Parries = 0
local Lerp_Radians = 0
local Last_Warping = tick()
local Previous_Velocity = {}
local Curving = tick()
local Runtime = Workspace.Runtime
local Connections_Manager = {}
local Selected_Parry_Type = "Camera"
local Infinity = false
local Parried = false
local Last_Parry = 0
local AutoParry = true
local Balls = Workspace:WaitForChild('Balls')
local CurrentBall = nil
local InputTask = nil
local RunTime = Workspace:FindFirstChild("Runtime")
local isMobile = UserInputService.TouchEnabled and not UserInputService.MouseEnabled
local StrafeSpeed = 36
local Training_Parried = false
local CosmeticsActive = false
local hit_Sound_Enabled = false
local headLoop = nil
local espEnabled = false
local espConnections = {}
local nameTagsEnabled = false
local nameTagsConnections = {}
local chamsEnabled = false
local chamsConnections = {}
local fullbrightEnabled = false
local originalLighting = {
    Brightness = Lighting.Brightness,
    Ambient = Lighting.Ambient,
    OutdoorAmbient = Lighting.OutdoorAmbient,
    FogEnd = Lighting.FogEnd
}
local crosshairEnabled = false
local crosshairGui = nil
local musicPlayer = nil
local skyboxConnection = nil
local shaderConnection = nil
local currentSkybox = nil
local currentShader = nil
local skyColorConnection = nil
local BallPauseEnabled = false
local BallPauseDistanceThreshold = 10

-- Remote Detection (from provided code)
task.spawn(function()
    for _, value in pairs(getgc()) do
        if type(value) == "function" and islclosure(value) then
            local protos = debug.getprotos(value)
            local upvalues = debug.getupvalues(value)
            local constants = debug.getconstants(value)
            if #protos == 4 and #upvalues == 24 and #constants >= 102 then
                Parry_Key = debug.getupvalue(value, 17)
                Parry_Remote = debug.getupvalue(value, 18)
                Parry_Arg = debug.getconstant(value, 64)
                break
            end
        end
    end
    if not Parry_Remote then
        warn("[Parry Remote Detection] Failed to find Parry_Remote")
    else
        print("[Parry Remote Detection] Success: Remote =", Parry_Remote and Parry_Remote.Name or "nil", "Key =", Parry_Key, "Arg =", Parry_Arg)
    end
end)

-- Utility Functions (from provided code)
local function BlockMovement(actionName, inputState, inputObject)
    return Enum.ContextActionResult.Sink
end

local function updateNavigation(guiObject)
    GuiService.SelectedObject = guiObject
end

local function performFirstPress(parryType)
    if parryType == 'F_Key' then
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, nil)
    elseif parryType == 'Left_Click' then
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
    elseif parryType == 'Navigation' then
        local button = Players.LocalPlayer.PlayerGui.Hotbar.Block
        updateNavigation(button)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
        task.wait(0.01)
        updateNavigation(nil)
    end
end

function create_animation(object, info, value)
    local animation = TweenService:Create(object, info, value)
    animation:Play()
    task.wait(info.Time)
    Debris:AddItem(animation, 0)
    animation:Destroy()
    animation = nil
end

-- Animation Handling (from provided code)
local Animation = {}
Animation.storage = {}
Animation.current = nil
Animation.track = nil

for _, v in pairs(ReplicatedStorage.Misc.Emotes:GetChildren()) do
    if v:IsA("Animation") and v:GetAttribute("EmoteName") then
        local Emote_Name = v:GetAttribute("EmoteName")
        Animation.storage[Emote_Name] = v
    end
end

local Emotes_Data = {}
for Object in pairs(Animation.storage) do
    table.insert(Emotes_Data, Object)
end
table.sort(Emotes_Data)

-- Auto Parry System (from provided code)
local Auto_Parry = {}

function Auto_Parry.Parry_Animation()
    local Parry_Animation = ReplicatedStorage.Shared.SwordAPI.Collection.Default:FindFirstChild('GrabParry')
    local Current_Sword = LocalPlayer.Character:GetAttribute('CurrentlyEquippedSword')

    if not Current_Sword or not Parry_Animation then
        return
    end

    local Sword_Data = ReplicatedStorage.Shared.ReplicatedInstances.Swords.GetSword:Invoke(Current_Sword)

    if not Sword_Data or not Sword_Data['AnimationType'] then
        return
    end

    for _, object in pairs(ReplicatedStorage.Shared.SwordAPI.Collection:GetChildren()) do
        if object.Name == Sword_Data['AnimationType'] then
            if object:FindFirstChild('GrabParry') or object:FindFirstChild('Grab') then
                local sword_animation_type = object:FindFirstChild('Grab') and 'Grab' or 'GrabParry'
                Parry_Animation = object[sword_animation_type]
            end
        end
    end

    Grab_Parry = LocalPlayer.Character.Humanoid.Animator:LoadAnimation(Parry_Animation)
    Grab_Parry:Play()
end

function Auto_Parry.Play_Animation(v)
    local Animations = Animation.storage[v]
    if not Animations then
        return false
    end
    local Animator = LocalPlayer.Character.Humanoid.Animator
    if Animation.track then
        Animation.track:Stop()
    end
    Animation.track = Animator:LoadAnimation(Animations)
    Animation.track:Play()
    Animation.current = v
end

function Auto_Parry.Get_Balls()
    local Balls = {}
    for _, Instance in pairs(Workspace.Balls:GetChildren()) do
        if Instance:GetAttribute('realBall') then
            Instance.CanCollide = false
            table.insert(Balls, Instance)
        end
    end
    return Balls
end

function Auto_Parry.Get_Ball()
    for _, Instance in pairs(Workspace.Balls:GetChildren()) do
        if Instance:GetAttribute('realBall') then
            Instance.CanCollide = false
            return Instance
        end
    end
end

function Auto_Parry.Lobby_Balls()
    for _, Instance in pairs(Workspace.TrainingBalls:GetChildren()) do
        if Instance:GetAttribute("realBall") then
            return Instance
        end
    end
end

local Closest_Entity = nil

function Auto_Parry.Closest_Player()
    local Max_Distance = math.huge
    local Found_Entity = nil
    for _, Entity in pairs(Workspace.Alive:GetChildren()) do
        if tostring(Entity) ~= tostring(LocalPlayer) then
            if Entity.PrimaryPart then
                local Distance = LocalPlayer:DistanceFromCharacter(Entity.PrimaryPart.Position)
                if Distance < Max_Distance then
                    Max_Distance = Distance
                    Found_Entity = Entity
                end
            end
        end
    end
    Closest_Entity = Found_Entity
    return Found_Entity
end

function Auto_Parry:Get_Entity_Properties()
    Auto_Parry.Closest_Player()
    if not Closest_Entity then
        return false
    end
    local Entity_Velocity = Closest_Entity.PrimaryPart.Velocity
    local Entity_Direction = (LocalPlayer.Character.PrimaryPart.Position - Closest_Entity.PrimaryPart.Position).Unit
    local Entity_Distance = (LocalPlayer.Character.PrimaryPart.Position - Closest_Entity.PrimaryPart.Position).Magnitude
    return {
        Velocity = Entity_Velocity,
        Direction = Entity_Direction,
        Distance = Entity_Distance
    }
end

function Auto_Parry.Parry_Data(Parry_Type)
    Auto_Parry.Closest_Player()
    local Events = {}
    local Camera = Workspace.CurrentCamera
    local Vector2_Mouse_Location
    if Last_Input == Enum.UserInputType.MouseButton1 or Last_Input == Enum.UserInputType.MouseButton2 or Last_Input == Enum.UserInputType.Keyboard then
        local Mouse_Location = UserInputService:GetMouseLocation()
        Vector2_Mouse_Location = {Mouse_Location.X, Mouse_Location.Y}
    else
        Vector2_Mouse_Location = {Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2}
    end
    if isMobile then
        Vector2_Mouse_Location = {Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2}
    end
    local Players_Screen_Positions = {}
    for _, v in pairs(Workspace.Alive:GetChildren()) do
        if v ~= LocalPlayer.Character then
            local worldPos = v.PrimaryPart.Position
            local screenPos, isOnScreen = Camera:WorldToScreenPoint(worldPos)
            if isOnScreen then
                Players_Screen_Positions[v] = Vector2.new(screenPos.X, screenPos.Y)
            end
            Events[tostring(v)] = screenPos
        end
    end
    if Parry_Type == 'Camera' then
        return {0, Camera.CFrame, Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'Backwards' then
        local Backwards_Direction = Camera.CFrame.LookVector * -10000
        Backwards_Direction = Vector3.new(Backwards_Direction.X, 0, Backwards_Direction.Z)
        return {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + Backwards_Direction), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'Straight' then
        local Aimed_Player = nil
        local Closest_Distance = math.huge
        local Mouse_Vector = Vector2.new(Vector2_Mouse_Location[1], Vector2_Mouse_Location[2])
        for _, v in pairs(Workspace.Alive:GetChildren()) do
            if v ~= LocalPlayer.Character then
                local worldPos = v.PrimaryPart.Position
                local screenPos, isOnScreen = Camera:WorldToScreenPoint(worldPos)
                if isOnScreen then
                    local playerScreenPos = Vector2.new(screenPos.X, screenPos.Y)
                    local distance = (Mouse_Vector - playerScreenPos).Magnitude
                    if distance < Closest_Distance then
                        Closest_Distance = distance
                        Aimed_Player = v
                    end
                end
            end
        end
        if Aimed_Player then
            return {0, CFrame.new(LocalPlayer.Character.PrimaryPart.Position, Aimed_Player.PrimaryPart.Position), Events, Vector2_Mouse_Location}
        else
            return {0, CFrame.new(LocalPlayer.Character.PrimaryPart.Position, Closest_Entity and Closest_Entity.PrimaryPart.Position or LocalPlayer.Character.PrimaryPart.Position), Events, Vector2_Mouse_Location}
        end
    elseif Parry_Type == 'Random' then
        return {0, CFrame.new(Camera.CFrame.Position, Vector3.new(math.random(-4000, 4000), math.random(-4000, 4000), math.random(-4000, 4000))), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'High' then
        local High_Direction = Camera.CFrame.UpVector * 10000
        return {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + High_Direction), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'Left' then
        local Left_Direction = Camera.CFrame.RightVector * 10000
        return {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - Left_Direction), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'Right' then
        local Right_Direction = Camera.CFrame.RightVector * 10000
        return {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + Right_Direction), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'RandomTarget' then
        local candidates = {}
        for _, v in pairs(Workspace.Alive:GetChildren()) do
            if v ~= LocalPlayer.Character and v.PrimaryPart then
                local screenPos, isOnScreen = Camera:WorldToScreenPoint(v.PrimaryPart.Position)
                if isOnScreen then
                    table.insert(candidates, {
                        character = v,
                        screenXY = { screenPos.X, screenPos.Y }
                    })
                end
            end
        end
        if #candidates > 0 then
            local pick = candidates[math.random(1, #candidates)]
            local lookCFrame = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, pick.character.PrimaryPart.Position)
            return {0, lookCFrame, Events, pick.screenXY}
        else
            return {0, Camera.CFrame, Events, { Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2 }}
        end
    end
    return Parry_Type
end

function Auto_Parry.Parry(parryType)
    if not Parry_Remote then
        warn("[Auto_Parry.Parry] Parry_Remote is nil, cannot parry")
        return false
    end

    local Parry_Data = Auto_Parry.Parry_Data(parryType or Selected_Parry_Type)
    if not Parry_Data then
        warn("[Auto_Parry.Parry] Failed to get Parry_Data")
        return false
    end

    local Hash
    if type(Parry_Arg) == "string" and string.match(Parry_Arg, "PARRY_HASH_FAKE") then
        Hash = nil
    else
        Hash = Parry_Arg
    end

    local success, err = pcall(function()
        Parry_Remote:FireServer(Hash, Parry_Key, Parry_Data[1], Parry_Data[2], Parry_Data[3], Parry_Data[4])
    end)
    if not success then
        warn("[Auto_Parry.Parry] Failed to fire remote:", err)
        return false
    end

    if not firstParryFired then
        performFirstPress(firstParryType)
        firstParryFired = true
    end

    if Parries > 7 then
        return false
    end

    Parries = Parries + 1
    task.delay(0.55, function()
        if Parries > 0 then
            Parries = Parries - 1
        end
    end)

    return true
end

function Auto_Parry.Linear_Interpolation(a, b, time_volume)
    return a + (b - a) * time_volume
end

function Auto_Parry.Is_Curved()
    local Ball = Auto_Parry.Get_Ball()
    if not Ball then
        return false
    end
    local Zoomies = Ball:FindFirstChild('zoomies')
    if not Zoomies then
        return false
    end
    local Velocity = Zoomies.VectorVelocity
    local Ball_Direction audition
System: Below is the Lua code for a new UI designed according to your specifications, incorporating the functionality from the provided code while creating a new UI with a black-and-white theme, smooth edges, draggable elements, and the specified layout. The UI persists across respawns and refreshes unless closed via the confirmation dialog, and all elements are draggable with smooth movement. The code reimplements tabs, buttons, sliders, and dropdowns to match the original functionality without copying the exact UI library code, using Roblox's native UI components with a custom black-and-white theme and glowing white borders.

### New UI Code

```lua
-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local VirtualInputManager = game:GetService("VirtualInputManager")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local Stats = game:GetService("Stats")
local GuiService = game:GetService("GuiService")

-- Local Player Variables
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Hotbar = PlayerGui:WaitForChild("Hotbar")
local ParryCD = Hotbar.Block.UIGradient
local AbilityCD = Hotbar.Ability.UIGradient

-- Original Variables (from provided code)
local Phantom = false
local Tornado_Time = tick()
local Last_Input = UserInputService:GetLastInputType()
local Vector2_Mouse_Location = nil
local Grab_Parry = nil
local Parry_Remote = true
local Parry_Key = nil
local Parry_Arg = nil
local Speed_Divisor_Multiplier = 1.1
local LobbyAP_Speed_Divisor_Multiplier = 1.1
local firstParryFired = false
local ParryThreshold = 2.5
local firstParryType = 'F_Key'
local Previous_Positions = {}
local Parries = 0
local Lerp_Radians = 0
local Last_Warping = tick()
local Previous_Velocity = {}
local Curving = tick()
local Runtime = Workspace.Runtime
local Connections_Manager = {}
local Selected_Parry_Type = "Camera"
local Infinity = false
local Parried = false
local Last_Parry = 0
local AutoParry = true
local Balls = Workspace:WaitForChild('Balls')
local CurrentBall = nil
local InputTask = nil
local RunTime = Workspace:FindFirstChild("Runtime")
local isMobile = UserInputService.TouchEnabled and not UserInputService.MouseEnabled
local StrafeSpeed = 36
local Training_Parried = false
local CosmeticsActive = false
local hit_Sound_Enabled = false
local headLoop = nil
local espEnabled = false
local espConnections = {}
local nameTagsEnabled = false
local nameTagsConnections = {}
local chamsEnabled = false
local chamsConnections = {}
local fullbrightEnabled = false
local originalLighting = {
    Brightness = Lighting.Brightness,
    Ambient = Lighting.Ambient,
    OutdoorAmbient = Lighting.OutdoorAmbient,
    FogEnd = Lighting.FogEnd
}
local crosshairEnabled = false
local crosshairGui = nil
local musicPlayer = nil
local skyboxConnection = nil
local shaderConnection = nil
local currentSkybox = nil
local currentShader = nil
local skyColorConnection = nil
local BallPauseEnabled = false
local BallPauseDistanceThreshold = 10

-- Remote Detection (from provided code)
task.spawn(function()
    for _, value in pairs(getgc()) do
        if type(value) == "function" and islclosure(value) then
            local protos = debug.getprotos(value)
            local upvalues = debug.getupvalues(value)
            local constants = debug.getconstants(value)
            if #protos == 4 and #upvalues == 24 and #constants >= 102 then
                Parry_Key = debug.getupvalue(value, 17)
                Parry_Remote = debug.getupvalue(value, 18)
                Parry_Arg = debug.getconstant(value, 64)
                break
            end
        end
    end
    if not Parry_Remote then
        warn("[Parry Remote Detection] Failed to find Parry_Remote")
    else
        print("[Parry Remote Detection] Success: Remote =", Parry_Remote and Parry_Remote.Name or "nil", "Key =", Parry_Key, "Arg =", Parry_Arg)
    end
end)

-- Utility Functions (from provided code)
local function BlockMovement(actionName, inputState, inputObject)
    return Enum.ContextActionResult.Sink
end

local function updateNavigation(guiObject)
    GuiService.SelectedObject = guiObject
end

local function performFirstPress(parryType)
    if parryType == 'F_Key' then
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, nil)
    elseif parryType == 'Left_Click' then
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
    elseif parryType == 'Navigation' then
        local button = Players.LocalPlayer.PlayerGui.Hotbar.Block
        updateNavigation(button)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
        task.wait(0.01)
        updateNavigation(nil)
    end
end

function create_animation(object, info, value)
    local animation = TweenService:Create(object, info, value)
    animation:Play()
    task.wait(info.Time)
    Debris:AddItem(animation, 0)
    animation:Destroy()
    animation = nil
end

-- Animation Handling (from provided code)
local Animation = {}
Animation.storage = {}
Animation.current = nil
Animation.track = nil

for _, v in pairs(ReplicatedStorage.Misc.Emotes:GetChildren()) do
    if v:IsA("Animation") and v:GetAttribute("EmoteName") then
        local Emote_Name = v:GetAttribute("EmoteName")
        Animation.storage[Emote_Name] = v
    end
end

local Emotes_Data = {}
for Object in pairs(Animation.storage) do
    table.insert(Emotes_Data, Object)
end
table.sort(Emotes_Data)

-- Auto Parry System (from provided code)
local Auto_Parry = {}

function Auto_Parry.Parry_Animation()
    local Parry_Animation = ReplicatedStorage.Shared.SwordAPI.Collection.Default:FindFirstChild('GrabParry')
    local Current_Sword = LocalPlayer.Character:GetAttribute('CurrentlyEquippedSword')

    if not Current_Sword or not Parry_Animation then
        return
    end

    local Sword_Data = ReplicatedStorage.Shared.ReplicatedInstances.Swords.GetSword:Invoke(Current_Sword)

    if not Sword_Data or not Sword_Data['AnimationType'] then
        return
    end

    for _, object in pairs(ReplicatedStorage.Shared.SwordAPI.Collection:GetChildren()) do
        if object.Name == Sword_Data['AnimationType'] then
            if object:FindFirstChild('GrabParry') or object:FindFirstChild('Grab') then
                local sword_animation_type = object:FindFirstChild('Grab') and 'Grab' or 'GrabParry'
                Parry_Animation = object[sword_animation_type]
            end
        end
    end

    Grab_Parry = LocalPlayer.Character.Humanoid.Animator:LoadAnimation(Parry_Animation)
    Grab_Parry:Play()
end

function Auto_Parry.Play_Animation(v)
    local Animations = Animation.storage[v]
    if not Animations then
        return false
    end
    local Animator = LocalPlayer.Character.Humanoid.Animator
    if Animation.track then
        Animation.track:Stop()
    end
    Animation.track = Animator:LoadAnimation(Animations)
    Animation.track:Play()
    Animation.current = v
end

function Auto_Parry.Get_Balls()
    local Balls = {}
    for _, Instance in pairs(Workspace.Balls:GetChildren()) do
        if Instance:GetAttribute('realBall') then
            Instance.CanCollide = false
            table.insert(Balls, Instance)
        end
    end
    return Balls
end

function Auto_Parry.Get_Ball()
    for _, Instance in pairs(Workspace.Balls:GetChildren()) do
        if Instance:GetAttribute('realBall') then
            Instance.CanCollide = false
            return Instance
        end
    end
end

function Auto_Parry.Lobby_Balls()
    for _, Instance in pairs(Workspace.TrainingBalls:GetChildren()) do
        if Instance:GetAttribute("realBall") then
            return Instance
        end
    end
end

local Closest_Entity = nil

function Auto_Parry.Closest_Player()
    local Max_Distance = math.huge
    local Found_Entity = nil
    for _, Entity in pairs(Workspace.Alive:GetChildren()) do
        if tostring(Entity) ~= tostring(LocalPlayer) then
            if Entity.PrimaryPart then
                local Distance = LocalPlayer:DistanceFromCharacter(Entity.PrimaryPart.Position)
                if Distance < Max_Distance then
                    Max_Distance = Distance
                    Found_Entity = Entity
                end
            end
        end
    end
    Closest_Entity = Found_Entity
    return Found_Entity
end

function Auto_Parry:Get_Entity_Properties()
    Auto_Parry.Closest_Player()
    if not Closest_Entity then
        return false
    end
    local Entity_Velocity = Closest_Entity.PrimaryPart.Velocity
    local Entity_Direction = (LocalPlayer.Character.PrimaryPart.Position - Closest_Entity.PrimaryPart.Position).Unit
    local Entity_Distance = (LocalPlayer.Character.PrimaryPart.Position - Closest_Entity.PrimaryPart.Position).Magnitude
    return {
        Velocity = Entity_Velocity,
        Direction = Entity_Direction,
        Distance = Entity_Distance
    }
end

function Auto_Parry.Parry_Data(Parry_Type)
    Auto_Parry.Closest_Player()
    local Events = {}
    local Camera = Workspace.CurrentCamera
    local Vector2_Mouse_Location
    if Last_Input == Enum.UserInputType.MouseButton1 or Last_Input == Enum.UserInputType.MouseButton2 or Last_Input == Enum.UserInputType.Keyboard then
        local Mouse_Location = UserInputService:GetMouseLocation()
        Vector2_Mouse_Location = {Mouse_Location.X, Mouse_Location.Y}
    else
        Vector2_Mouse_Location = {Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2}
    end
    if isMobile then
        Vector2_Mouse_Location = {Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2}
    end
    local Players_Screen_Positions = {}
    for _, v in pairs(Workspace.Alive:GetChildren()) do
        if v ~= LocalPlayer.Character then
            local worldPos = v.PrimaryPart.Position
            local screenPos, isOnScreen = Camera:WorldToScreenPoint(worldPos)
            if isOnScreen then
                Players_Screen_Positions[v] = Vector2.new(screenPos.X, screenPos.Y)
            end
            Events[tostring(v)] = screenPos
        end
    end
    if Parry_Type == 'Camera' then
        return {0, Camera.CFrame, Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'Backwards' then
        local Backwards_Direction = Camera.CFrame.LookVector * -10000
        Backwards_Direction = Vector3.new(Backwards_Direction.X, 0, Backwards_Direction.Z)
        return {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + Backwards_Direction), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'Straight' then
        local Aimed_Player = nil
        local Closest_Distance = math.huge
        local Mouse_Vector = Vector2.new(Vector2_Mouse_Location[1], Vector2_Mouse_Location[2])
        for _, v in pairs(Workspace.Alive:GetChildren()) do
            if v ~= LocalPlayer.Character then
                local worldPos = v.PrimaryPart.Position
                local screenPos, isOnScreen = Camera:WorldToScreenPoint(worldPos)
                if isOnScreen then
                    local playerScreenPos = Vector2.new(screenPos.X, screenPos.Y)
                    local distance = (Mouse_Vector - playerScreenPos).Magnitude
                    if distance < Closest_Distance then
                        Closest_Distance = distance
                        Aimed_Player = v
                    end
                end
            end
        end
        if Aimed_Player then
            return {0, CFrame.new(LocalPlayer.Character.PrimaryPart.Position, Aimed_Player.PrimaryPart.Position), Events, Vector2_Mouse_Location}
        else
            return {0, CFrame.new(LocalPlayer.Character.PrimaryPart.Position, Closest_Entity and Closest_Entity.PrimaryPart.Position or LocalPlayer.Character.PrimaryPart.Position), Events, Vector2_Mouse_Location}
        end
    elseif Parry_Type == 'Random' then
        return {0, CFrame.new(Camera.CFrame.Position, Vector3.new(math.random(-4000, 4000), math.random(-4000, 4000), math.random(-4000, 4000))), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'High' then
        local High_Direction = Camera.CFrame.UpVector * 10000
        return {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + High_Direction), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'Left' then
        local Left_Direction = Camera.CFrame.RightVector * 10000
        return {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - Left_Direction), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'Right' then
        local Right_Direction = Camera.CFrame.RightVector * 10000
        return {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + Right_Direction), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'RandomTarget' then
        local candidates = {}
        for _, v in pairs(Workspace.Alive:GetChildren()) do
            if v ~= LocalPlayer.Character and v.PrimaryPart then
                local screenPos, isOnScreen = Camera:WorldToScreenPoint(v.PrimaryPart.Position)
                if isOnScreen then
                    table.insert(candidates, {
                        character = v,
                        screenXY = { screenPos.X, screenPos.Y }
                    })
                end
            end
        end
        if #candidates > 0 then
            local pick = candidates[math.random(1, #candidates)]
            local lookCFrame = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, pick.character.PrimaryPart.Position)
            return {0, lookCFrame, Events, pick.screenXY}
        else
            return {0, Camera.CFrame, Events, { Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2 }}
        end
    end
    return Parry_Type
end

function Auto_Parry.Parry(parryType)
    if not Parry_Remote then
        warn("[Auto_Parry.Parry] Parry_Remote is nil, cannot parry")
        return false
    end

    local Parry_Data = Auto_Parry.Parry_Data(parryType or Selected_Parry_Type)
    if not Parry_Data then
        warn("[Auto_Parry.Parry] Failed to get Parry_Data")
        return false
    end

    local Hash
    if type(Parry_Arg) == "string" and string.match(Parry_Arg, "PARRY_HASH_FAKE") then
        Hash = nil
    else
        Hash = Parry_Arg
    end

    local success, err = pcall(function()
        Parry_Remote:FireServer(Hash, Parry_Key, Parry_Data[1], Parry_Data[2], Parry_Data[3], Parry_Data[4])
    end)
    if not success then
        warn("[Auto_Parry.Parry] Failed to fire remote:", err)
        return false
    end

    if not firstParryFired then
        performFirstPress(firstParryType)
        firstParryFired = true
    end

    if Parries > 7 then
        return false
    end

    Parries = Parries + 1
    task.delay(0.55, function()
        if Parries > 0 then
            Parries = Parries - 1
        end
    end)

    return true
end

function Auto_Parry.Linear_Interpolation(a, b, time_volume)
    return a + (b - a) * time_volume
end

function Auto_Parry.Is_Curved()
    local Ball = Auto_Parry.Get_Ball()
    if not Ball then
        return false
    end
    local Zoomies = Ball:FindFirstChild('zoomies')
    if not Zoomies then
        return false
    end
    local Velocity = Zoomies.VectorVelocity
    local Ball_Direction = Velocity.Unit
    local Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Unit
    local Dot = Direction:Dot(Ball_Direction)
    local Speed = Velocity.Magnitude
    local Speed_Threshold = math.min(Speed / 100, 40)
    local Direction_Difference = (Ball_Direction - Velocity).Unit
    local Direction_Similarity = Direction:Dot(Direction_Difference)
    local Dot_Difference = Dot - Direction_Similarity
    local Distance = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Magnitude
    local Pings = Stats.Network.ServerStatsItem['Data Ping']:GetValue()
    local Dot_Threshold = 0.5 - (Pings / 1000)
    local Reach_Time = Distance / Speed - (Pings / 1000)
    local Ball_Distance_Threshold = 15 - math.min(Distance / 1000, 15) + Speed_Threshold
    local Clamped_Dot = math.clamp(Dot, -1, 1)
    local Radians = math.rad(math.asin(Clamped_Dot))
    Lerp_Radians = Auto_Parry.Linear_Interpolation(Lerp_Radians, Radians, 0.8)
    if Speed > 100 and Reach_Time > Pings / 10 then
        Ball_Distance_Threshold = math.max(Ball_Distance_Threshold - 15, 15)
    end
    if Distance < Ball_Distance_Threshold then
        return false
    end
    if Dot_Difference < Dot_Threshold then
        return true
    end
    if Lerp_Radians < 0.018 then
        Last_Warping = tick()
    end
    if (tick() - Last_Warping) < (Reach_Time / 1.5) then
        return true
    end
    if (tick() - Curving) < (Reach_Time / 1.5) then
        return true
    end
    return Dot < Dot_Threshold
end

function Auto_Parry:Get_Ball_Properties()
    local Ball = Auto_Parry.Get_Ball()
    local Ball_Velocity = Vector3.zero
    local Ball_Origin = Ball
    local Ball_Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball_Origin.Position).Unit
    local Ball_Distance = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Magnitude
    local Ball_Dot = Ball_Direction:Dot(Ball_Velocity.Unit)
    return {
        Velocity = Ball_Velocity,
        Direction = Ball_Direction,
        Distance = Ball_Distance,
        Dot = Ball_Dot
    }
end

function Auto_Parry.Spam_Service(self)
    local Ball = Auto_Parry.Get_Ball()
    local Entity = Auto_Parry.Closest_Player()
    if not Ball or not Entity or not Entity.PrimaryPart then
        return false
    end
    local Spam_Accuracy = 0
    local Velocity = Ball.AssemblyLinearVelocity
    local Speed = Velocity.Magnitude
    local Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Unit
    local Dot = Direction:Dot(Velocity.Unit)
    local Target_Position = Entity.PrimaryPart.Position
    local Target_Distance = LocalPlayer:DistanceFromCharacter(Target_Position)
    local Maximum_Spam_Distance = self.Ping + math.min(Speed / 6, 95)
    if self.Entity_Properties.Distance > Maximum_Spam_Distance or self.Ball_Properties.Distance > Maximum_Spam_Distance or Target_Distance > Maximum_Spam_Distance then
        return Spam_Accuracy
    end
    local Maximum_Speed = 5 - math.min(Speed / 5, 5)
    local Maximum_Dot = math.clamp(Dot, -1, 0) * Maximum_Speed
    Spam_Accuracy = Maximum_Spam_Distance - Maximum_Dot
    return Spam_Accuracy
end

local function GetBall()
    for _, Ball in ipairs(Balls:GetChildren()) do
        if Ball:FindFirstChild("ff") then
            return Ball
        end
    end
    return nil
end

local function isCooldownInEffect1(uigradient)
    return uigradient.Offset.Y < 0.4
end

local function isCooldownInEffect2(uigradient)
    return uigradient.Offset.Y == 0.5
end

local function cooldownProtection()
    if isCooldownInEffect1(ParryCD) then
        ReplicatedStorage.Remotes.AbilityButtonPress:Fire()
        return true
    end
    return false
end

local function AutoAbility()
    if isCooldownInEffect2(AbilityCD) then
        if LocalPlayer.Character.Abilities["Raging Deflection"].Enabled or LocalPlayer.Character.Abilities["Rapture"].Enabled or LocalPlayer.Character.Abilities["Calming Deflection"].Enabled or LocalPlayer.Character.Abilities["Aerodynamic Slash"].Enabled or LocalPlayer.Character.Abilities["Fracture"].Enabled or LocalPlayer.Character.Abilities["Death Slash"].Enabled then
            Parried = true
            ReplicatedStorage.Remotes.AbilityButtonPress:Fire()
            task.wait(2.432)
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("DeathSlashShootActivation"):FireServer(true)
            return true
        end
    end
    return false
end

-- New Functions for Additions (from provided code)
local function applySkyColor(color)
    Lighting.Ambient = color
    Lighting.OutdoorAmbient = color
    if skyColorConnection then
        skyColorConnection:Disconnect()
    end
    skyColorConnection = RunService.Heartbeat:Connect(function()
        Lighting.Ambient = color
        Lighting.OutdoorAmbient = color
    end)
end

local function applySkybox(skyboxType)
    if currentSkybox then
        currentSkybox:Destroy()
    end
    local sky = Instance.new("Sky")
    sky.Parent = Lighting
    currentSkybox = sky
    if skyboxType == "Midnight" then
        sky.SkyboxBk = "rbxassetid://159067838"
        sky.SkyboxDn = "rbxassetid://159067846"
        sky.SkyboxFt = "rbxassetid://159067853"
        sky.SkyboxLf = "rbxassetid://159067860"
        sky.SkyboxRt = "rbxassetid://159067868"
        sky.SkyboxUp = "rbxassetid://159067875"
    elseif skyboxType == "Space" then
        sky.SkyboxBk = "rbxassetid://159248189"
        sky.SkyboxDn = "rbxassetid://159248192"
        sky.SkyboxFt = "rbxassetid://159248194"
        sky.SkyboxLf = "rbxassetid://159248196"
        sky.SkyboxRt = "rbxassetid://159248198"
        sky.SkyboxUp = "rbxassetid://159248200"
    elseif skyboxType == "Galaxy" then
        sky.SkyboxBk = "rbxassetid://183778618"
        sky.SkyboxDn = "rbxassetid://183778625"
        sky.SkyboxFt = "rbxassetid://183778630"
        sky.SkyboxLf = "rbxassetid://183778635"
        sky.SkyboxRt = "rbxassetid://183778641"
        sky.SkyboxUp = "rbxassetid://183778647"
    elseif skyboxType == "Christmas" then
        sky.SkyboxBk = "rbxassetid://383212508"
        sky.SkyboxDn = "rbxassetid://383212513"
        sky.SkyboxFt = "rbxassetid://383212518"
        sky.SkyboxLf = "rbxassetid://383212523"
        sky.SkyboxRt = "rbxassetid://383212528"
        sky.SkyboxUp = "rbxassetid://383212533"
    end
end

local function applyShader(shaderType)
    if currentShader then
        currentShader:Destroy()
    end
    local colorCorrection = Instance.new("ColorCorrectionEffect")
    colorCorrection.Parent = Lighting
    currentShader = colorCorrection
    if shaderType == "Mid Purple Day" then
        colorCorrection.TintColor = Color3.fromRGB(200, 150, 255)
        colorCorrection.Brightness = 0.1
        colorCorrection.Contrast = 0.1
        colorCorrection.Saturation = 0.2
    elseif shaderType == "Mid Pink Day" then
        colorCorrection.TintColor = Color3.fromRGB(255, 150, 200)
        colorCorrection.Brightness = 0.1
        colorCorrection.Contrast = 0.1
        colorCorrection.Saturation = 0.2
    elseif shaderType == "Mid Day" then
        colorCorrection.TintColor = Color3.fromRGB(255, 255, 255)
        colorCorrection.Brightness = 0.15
        colorCorrection.Contrast = 0.1
        colorCorrection.Saturation = 0.1
    elseif shaderType == "Evening" then
        colorCorrection.TintColor = Color3.fromRGB(255, 200, 150)
        colorCorrection.Brightness = 0.05
        colorCorrection.Contrast = 0.1
        colorCorrection.Saturation = 0.15
    elseif shaderType == "Night" then
        colorCorrection.TintColor = Color3.fromRGB(100, 100, 200)
        colorCorrection.Brightness = -0.1
        colorCorrection.Contrast = 0.1
        colorCorrection.Saturation = 0.1
    end
end

local function playMusic(musicId)
    if musicPlayer then
        musicPlayer:Destroy()
    end
    if musicId == "" then
        return
    end
    musicPlayer = Instance.new("Sound")
    musicPlayer.SoundId = "rbxassetid://" .. musicId
    musicPlayer.Parent = LocalPlayer.Character
    musicPlayer:Play()
end

local function pauseMusic()
    if musicPlayer then
        musicPlayer:Pause()
    end
end

local function pauseBall()
    local Ball = Auto_Parry.Get_Ball()
    if not Ball or not BallPauseEnabled then return end
    local Zoomies = Ball:FindFirstChild('zoomies')
    if not Zoomies then return end
    local Ball_Target = Ball:GetAttribute('target')
    if Ball_Target ~= tostring(LocalPlayer) then return end
    local Distance = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Magnitude
    local Velocity = Zoomies.VectorVelocity
    local Speed = Velocity.Magnitude
    local Ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue() / 1000
    local Reach_Time = Distance / Speed - Ping
    if Distance <= BallPauseDistanceThreshold and Reach_Time < 0.1 then
        ReplicatedStorage.Remotes.InfinityBall:FireServer(true)
        task.wait(0.1)
        ReplicatedStorage.Remotes.InfinityBall:FireServer(false)
    end
end

-- UI Setup
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CustomUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = CoreGui
screenGui.IgnoreGuiInset = true

-- Main UI Frame
local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 600, 0, 400)
mainFrame.Position = UDim2.new(0.5, -300, 0.5, -200)
mainFrame.BackgroundColor3 = Color3.fromRGB(8, 8, 8)
mainFrame.BackgroundTransparency = 0.7
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Parent = screenGui

local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0, 12)
uiCorner.Parent = mainFrame

local uiStroke = Instance.new("UIStroke")
uiStroke.Thickness = 2
uiStroke.Color = Color3.fromRGB(255, 255, 255)
uiStroke.Parent = mainFrame

local shadow = Instance.new("UIStroke")
shadow.Thickness = 4
shadow.Color = Color3.fromRGB(255, 255, 255)
shadow.Transparency = 0.5
shadow.Parent = mainFrame

-- Right Square Frame
local rightSquare = Instance.new("Frame")
rightSquare.Size = UDim2.new(0, 300, 0, 200)
rightSquare.Position = UDim2.new(1, 20, 0.5, -100)
rightSquare.BackgroundColor3 = Color3.fromRGB(9, 9, 9)
rightSquare.BackgroundTransparency = 0.7
rightSquare.BorderSizePixel = 0
rightSquare.Active = true
rightSquare.Parent = mainFrame

local rightSquareCorner = Instance.new("UICorner")
rightSquareCorner.CornerRadius = UDim.new(0, 12)
rightSquareCorner.Parent = rightSquare

local rightSquareStroke = Instance.new("UIStroke")
rightSquareStroke.Thickness = 2
rightSquareStroke.Color = Color3.fromRGB(255, 255, 255)
rightSquareStroke.Parent = rightSquare

-- Left Rectangle Frame
local leftRectangle = Instance.new("Frame")
leftRectangle.Size = UDim2.new(0, 150, 0, 300)
leftRectangle.Position = UDim2.new(-0.5, -170, 0.5, -150)
leftRectangle.BackgroundColor3 = Color3.fromRGB(9, 9, 9)
leftRectangle.BackgroundTransparency = 0.7
leftRectangle.BorderSizePixel = 0
leftRectangle.Active = true
leftRectangle.Parent = mainFrame

local leftRectangleCorner = Instance.new("UICorner")
leftRectangleCorner.CornerRadius = UDim.new(0, 12)
leftRectangleCorner.Parent = leftRectangle

local leftRectangleStroke = Instance.new("UIStroke")
leftRectangleStroke.Thickness = 2
leftRectangleStroke.Color = Color3.fromRGB(255, 255, 255)
leftRectangleStroke.Parent = leftRectangle

-- Traffic Light Circles
local redCircle = Instance.new("Frame")
redCircle.Size = UDim2.new(0, 20, 0, 20)
redCircle.Position = UDim2.new(0, 10, 0, 10)
redCircle.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
redCircle.Parent = mainFrame
local redCircleCorner = Instance.new("UICorner")
redCircleCorner.CornerRadius = UDim.new(0.5, 0)
redCircleCorner.Parent = redCircle

local orangeCircle = Instance.new("Frame")
orangeCircle.Size = UDim2.new(0, 20, 0, 20)
orangeCircle.Position = UDim2.new(0, 40, 0, 10)
orangeCircle.BackgroundColor3 = Color3.fromRGB(255, 165, 0)
orangeCircle.Parent = mainFrame
local orangeCircleCorner = Instance.new("UICorner")
orangeCircleCorner.CornerRadius = UDim.new(0.5, 0)
orangeCircleCorner.Parent = orangeCircle

local greenCircle = Instance.new("Frame")
greenCircle.Size = UDim2.new(0, 20, 0, 20)
greenCircle.Position = UDim2.new(0, 70, 0, 10)
greenCircle.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
greenCircle.Parent = mainFrame
local greenCircleCorner = Instance.new("UICorner")
greenCircleCorner.CornerRadius = UDim.new(0.5, 0)
greenCircleCorner.Parent = greenCircle

-- Window Controls
local closeButton = Instance.new("TextButton")
closeButton.Size = UDim2.new(0, 30, 0, 30)
closeButton.Position = UDim2.new(1, -40, 0, 10)
closeButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
closeButton.Text = ""
closeButton.Parent = mainFrame
local closeButtonCorner = Instance.new("UICorner")
closeButtonCorner.CornerRadius = UDim.new(0.5, 0)
closeButtonCorner.Parent = closeButton

local minimizeButton = Instance.new("TextButton")
minimizeButton.Size = UDim2.new(0, 30, 0, 30)
minimizeButton.Position = UDim2.new(1, -80, 0, 10)
minimizeButton.BackgroundColor3 = Color3.fromRGB(255, 255, 0)
minimizeButton.Text = ""
minimizeButton.Parent = mainFrame
local minimizeButtonCorner = Instance.new("UICorner")
minimizeButtonCorner.CornerRadius = UDim.new(0.5, 0)
minimizeButtonCorner.Parent = minimizeButton

local extendButton = Instance.new("TextButton")
extendButton.Size = UDim2.new(0, 30, 0, 30)
extendButton.Position = UDim2.new(1, -120, 0, 10)
extendButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
extendButton.Text = ""
extendButton.Parent = mainFrame
local extendButtonCorner = Instance.new("UICorner")
extendButtonCorner.CornerRadius = UDim.new(0.5, 0)
extendButtonCorner.Parent = extendButton

-- Confirmation Dialog
local confirmDialog = Instance.new("Frame")
confirmDialog.Size = UDim2.new(0, 300, 0, 150)
confirmDialog.Position = UDim2.new(0.5, -150, 0.5, -75)
confirmDialog.BackgroundColor3 = Color3.fromRGB(8, 8, 8)
confirmDialog.BackgroundTransparency = 0
confirmDialog.Visible = false
confirmDialog.Parent = mainFrame
local confirmDialogCorner = Instance.new("UICorner")
confirmDialogCorner.CornerRadius = UDim.new(0, 12)
confirmDialogCorner.Parent = confirmDialog
local confirmDialogStroke = Instance.new("UIStroke")
confirmDialogStroke.Thickness = 2
confirmDialogStroke.Color = Color3.fromRGB(255, 255, 255)
confirmDialogStroke.Parent = confirmDialog

local confirmText = Instance.new("TextLabel")
confirmText.Size = UDim2.new(1, 0, 0, 50)
confirmText.Position = UDim2.new(0, 0, 0, 20)
confirmText.BackgroundTransparency = 1
confirmText.Text = "Are you sure you want to close Visual?"
confirmText.TextColor3 = Color3.fromRGB(255, 255, 255)
confirmText.Font = Enum.Font.GothamBold
confirmText.TextSize = 16
confirmText.Parent = confirmDialog

local yesButton = Instance.new("TextButton")
yesButton.Size = UDim2.new(0, 100, 0, 40)
yesButton.Position = UDim2.new(0.25, -50, 0.75, -20)
yesButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
yesButton.Text = "Yes"
yesButton.TextColor3 = Color3.fromRGB(255, 255, 255)
yesButton.Font = Enum.Font.Gotham
yesButton.TextSize = 14
yesButton.Parent = confirmDialog
local yesButtonCorner = Instance.new("UICorner")
yesButtonCorner.CornerRadius = UDim.new(0, 8)
yesButtonCorner.Parent = yesButton

local noButton = Instance.new("TextButton")
noButton.Size = UDim2.new(0, 100, 0, 40)
noButton.Position = UDim2.new(0.75, -50, 0.75, -20)
noButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
noButton.Text = "No"
noButton.TextColor3 = Color3.fromRGB(255, 255, 255)
noButton.Font = Enum.Font.Gotham
noButton.TextSize = 14
noButton.Parent = confirmDialog
local noButtonCorner = Instance.new("UICorner")
noButtonCorner.CornerRadius = UDim.new(0, 8)
noButtonCorner.Parent = noButton

-- Minimized Frame
local minimizedFrame = Instance.new("Frame")
minimizedFrame.Size = UDim2.new(0, 200, 0, 50)
minimizedFrame.Position = UDim2.new(0.5, -100, 0.5, -25)
minimizedFrame.BackgroundColor3 = Color3.fromRGB(8, 8, 8)
minimizedFrame.BackgroundTransparency = 0.7
minimizedFrame.BorderSizePixel = 0
minimizedFrame.Active = true
minimizedFrame.Visible = false
minimizedFrame.Parent = screenGui
local minimizedFrameCorner = Instance.new("UICorner")
minimizedFrameCorner.CornerRadius = UDim.new(0, 12)
minimizedFrameCorner.Parent = minimizedFrame
local minimizedFrameStroke = Instance.new("UIStroke")
minimizedFrameStroke.Thickness = 2
minimizedFrameStroke.Color = Color3.fromRGB(255, 255, 255)
minimizedFrameStroke.Parent = minimizedFrame

local minimizedCloseButton = Instance.new("TextButton")
minimizedCloseButton.Size = UDim2.new(0, 30, 0, 30)
minimizedCloseButton.Position = UDim2.new(1, -40, 0, 10)
minimizedCloseButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
minimizedCloseButton.Text = ""
minimizedCloseButton.Parent = minimizedFrame
local minimizedCloseButtonCorner = Instance.new("UICorner")
minimizedCloseButtonCorner.CornerRadius = UDim.new(0.5, 0)
minimizedCloseButtonCorner.Parent = minimizedCloseButton

local unminimizeButton = Instance.new("TextButton")
unminimizeButton.Size = UDim2.new(0, 30, 0, 30)
unminimizeButton.Position = UDim2.new(1, -80, 0, 10)
unminimizeButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
unminimizeButton.Text = ""
unminimizeButton.Parent = minimizedFrame
local unminimizeButtonCorner = Instance.new("UICorner")
unminimizeButtonCorner.CornerRadius = UDim.new(0.5, 0)
unminimizeButtonCorner.Parent = unminimizeButton

-- Dragging Functionality
local function makeDraggable(frame)
    local dragging = false
    local dragInput, dragStart, startPos

    local function update(input)
        local delta = input.Position - dragStart
        local newPos = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        TweenService:Create(frame, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = newPos}):Play()
    end

    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    frame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    RunService.RenderStepped:Connect(function()
        if dragging and dragInput then
            update(dragInput)
        end
    end)
end

makeDraggable(mainFrame)
makeDraggable(rightSquare)
makeDraggable(leftRectangle)
makeDraggable(minimizedFrame)

-- Window Control Handlers
closeButton.MouseButton1Click:Connect(function()
    confirmDialog.Visible = true
end)

yesButton.MouseButton1Click:Connect(function()
    local tween = TweenService:Create(mainFrame, TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {Size = UDim2.new(0, 0, 0, 0), Position = UDim2.new(0.5, 0, 0.5, 0)})
    tween:Play()
    tween.Completed:Connect(function()
        screenGui:Destroy()
    end)
end)

noButton.MouseButton1Click:Connect(function()
    confirmDialog.Visible = false
end)

minimizeButton.MouseButton1Click:Connect(function()
    mainFrame.Visible = false
    minimizedFrame.Visible = true
    local tween = TweenService:Create(minimizedFrame, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(0, 200, 0, 50)}):Play()
end)

unminimizeButton.MouseButton1Click:Connect(function()
    minimizedFrame.Visible = false
    mainFrame.Visible = true
    local tween = TweenService:Create(mainFrame, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(0, 600, 0, 400)}):Play()
end)

minimizedCloseButton.MouseButton1Click:Connect(function()
    confirmDialog.Visible = true
    confirmDialog.Parent = minimizedFrame
end)

-- Persist UI on Respawn
LocalPlayer.CharacterAdded:Connect(function()
    if screenGui.Parent then
        screenGui.Parent = CoreGui
    end
end)

-- Tab System
local tabsFrame = Instance.new("Frame")
tabsFrame.Size = UDim2.new(0, 150, 1, -50)
tabsFrame.Position = UDim2.new(0, 10, 0, 40)
tabsFrame.BackgroundTransparency = 1
tabsFrame.Parent = mainFrame

local tabContainer = Instance.new("Frame")
tabContainer.Size = UDim2.new(1, -160, 1, -50)
tabContainer.Position = UDim2.new(0, 160, 0, 40)
tabContainer.BackgroundTransparency = 1
tabContainer.Parent = mainFrame

local tabs = {"Blatant", "Player", "Visuals", "Misc", "Credits"}
local tabFrames = {}
local tabButtons = {}
local currentTab = nil

for i, tabName in ipairs(tabs) do
    local tabButton = Instance.new("TextButton")
    tabButton.Size = UDim2.new(1, 0, 0, 40)
    tabButton.Position = UDim2.new(0, 0, 0, (i-1)*45)
    tabButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    tabButton.BackgroundTransparency = 0.8
    tabButton.Text = tabName
    tabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    tabButton.Font = Enum.Font.Gotham
    tabButton.TextSize = 14
    tabButton.Parent = tabsFrame
    local tabButtonCorner = Instance.new("UICorner")
    tabButtonCorner.CornerRadius = UDim.new(0, 8)
    tabButtonCorner.Parent = tabButton
    local tabButtonStroke = Instance.new("UIStroke")
    tabButtonStroke.Thickness = 1
    tabButtonStroke.Color = Color3.fromRGB(255, 255, 255)
    tabButtonStroke.Parent = tabButton

    local tabFrame = Instance.new("Frame")
    tabFrame.Size = UDim2.new(1, 0, 1, 0)
    tabFrame.BackgroundTransparency = 1
    tabFrame.Visible = false
    tabFrame.Parent = tabContainer
    tabFrames[tabName] = tabFrame

    tabButton.MouseButton1Click:Connect(function()
        if currentTab then
            tabFrames[currentTab].Visible = false
        end
        tabFrame.Visible = true
        currentTab = tabName
    end)

    tabButtons[tabName] = tabButton
end

tabFrames[tabs[1]].Visible = true
currentTab = tabs[1]

-- UI Component Creators
local function createSection(parent, title)
    local sectionFrame = Instance.new("Frame")
    sectionFrame.Size = UDim2.new(1, -10, 0, 100)
    sectionFrame.Position = UDim2.new(0, 5, 0, 0)
    sectionFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    sectionFrame.BackgroundTransparency = 0.8
    sectionFrame.Parent = parent
    local sectionCorner = Instance.new("UICorner")
    sectionCorner.CornerRadius = UDim.new(0, 8)
    sectionCorner.Parent = sectionFrame
    local sectionStroke = Instance.new("UIStroke")
    sectionStroke.Thickness = 1
    sectionStroke.Color = Color3.fromRGB(255, 255, 255)
    sectionStroke.Parent = sectionFrame

    local sectionTitle = Instance.new("TextLabel")
    sectionTitle.Size = UDim2.new(1, 0, 0, 20)
    sectionTitle.BackgroundTransparency = 1
    sectionTitle.Text = title
    sectionTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
    sectionTitle.Font = Enum.Font.GothamBold
    sectionTitle.TextSize = 14
    sectionTitle.Parent = sectionFrame

    local contentFrame = Instance.new("Frame")
    contentFrame.Size = UDim2.new(1, 0, 1, -25)
    contentFrame.Position = UDim2.new(0, 0, 0, 25)
    contentFrame.BackgroundTransparency = 1
    contentFrame.Parent = sectionFrame

    local uiListLayout = Instance.new("UIListLayout")
    uiListLayout.Padding = UDim.new(0, 5)
    uiListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    uiListLayout.Parent = contentFrame

    return contentFrame
end

local function createToggle(parent, text, callback, flag)
    local toggleFrame = Instance.new("Frame")
    toggleFrame.Size = UDim2.new(1, 0, 0, 30)
    toggleFrame.BackgroundTransparency = 1
    toggleFrame.Parent = parent

    local toggleLabel = Instance.new("TextLabel")
    toggleLabel.Size = UDim2.new(0.8, 0, 1, 0)
    toggleLabel.BackgroundTransparency = 1
    toggleLabel.Text = text
    toggleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggleLabel.Font = Enum.Font.Gotham
    toggleLabel.TextSize = 12
    toggleLabel.TextXAlignment = Enum.TextXAlignment.Left
    toggleLabel.Parent = toggleFrame

    local toggleButton = Instance.new("TextButton")
    toggleButton.Size = UDim2.new(0, 40, 0, 20)
    toggleButton.Position = UDim2.new(0.85, 0, 0.5, -10)
    toggleButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    toggleButton.Text = ""
    toggleButton.Parent = toggleFrame
    local toggleButtonCorner = Instance.new("UICorner")
    toggleButtonCorner.CornerRadius = UDim.new(0, 10)
    toggleButtonCorner.Parent = toggleButton
    local toggleButtonStroke = Instance.new("UIStroke")
    toggleButtonStroke.Thickness = 1
    toggleButtonStroke.Color = Color3.fromRGB(255, 255, 255)
    toggleButtonStroke.Parent = toggleButton

    local toggleIndicator = Instance.new("Frame")
    toggleIndicator.Size = UDim2.new(0, 18, 0, 18)
    toggleIndicator.Position = UDim2.new(0, 2, 0.5, -9)
    toggleIndicator.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    toggleIndicator.Parent = toggleButton
    local toggleIndicatorCorner = Instance.new("UICorner")
    toggleIndicatorCorner.CornerRadius = UDim.new(0.5, 0)
    toggleIndicatorCorner.Parent = toggleIndicator

    local state = false
    local flags = flag or {}
    toggleButton.MouseButton1Click:Connect(function()
        state = not state
        toggleIndicator.BackgroundColor3 = state and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(100, 100, 100)
        if flag then
            flags[flag] = state
        end
        callback(state)
    end)

    return toggleFrame
end

local function createSlider(parent, text, min, max, default, callback)
    local sliderFrame = Instance.new("Frame")
    sliderFrame.Size = UDim2.new(1, 0, 0, 50)
    sliderFrame.BackgroundTransparency = 1
    sliderFrame.Parent = parent

    local sliderLabel = Instance.new("TextLabel")
    sliderLabel.Size = UDim2.new(1, 0, 0, 20)
    sliderLabel.BackgroundTransparency = 1
    sliderLabel.Text = text
    sliderLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    sliderLabel.Font = Enum.Font.Gotham
    sliderLabel.TextSize = 12
    sliderLabel.TextXAlignment = Enum.TextXAlignment.Left
    sliderLabel.Parent = sliderFrame

    local sliderBar = Instance.new("Frame")
    sliderBar.Size = UDim2.new(1, -10, 0, 10)
    sliderBar.Position = UDim2.new(0, 5, 0, 25)
    sliderBar.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    sliderBar.Parent = sliderFrame
    local sliderBarCorner = Instance.new("UICorner")
    sliderBarCorner.CornerRadius = UDim.new(0, 5)
    sliderBarCorner.Parent = sliderBar

    local sliderFill = Instance.new("Frame")
    sliderFill.Size = UDim2.new(0, 0, 1, 0)
    sliderFill.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    sliderFill.Parent = sliderBar
    local sliderFillCorner = Instance.new("UICorner")
    sliderFillCorner.CornerRadius = UDim.new(0, 5)
    sliderFillCorner.Parent = sliderFill

    local sliderKnob = Instance.new("Frame")
    sliderKnob.Size = UDim2.new(0, 20, 0, 20)
    sliderKnob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    sliderKnob.Parent = sliderBar
    local sliderKnobCorner = Instance.new("UICorner")
    sliderKnobCorner.CornerRadius = UDim.new(0.5, 0)
    sliderKnobCorner.Parent = sliderKnob

    local valueLabel = Instance.new("TextLabel")
    valueLabel.Size = UDim2.new(0, 50, 0, 20)
    valueLabel.Position = UDim2.new(1, -60, 0, 30)
    valueLabel.BackgroundTransparency = 1
    valueLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    valueLabel.Font = Enum.Font.Gotham
    valueLabel.TextSize = 12
    valueLabel.Parent = sliderFrame

    local currentValue = default
    valueLabel.Text = tostring(currentValue)

    local dragging = false
    sliderKnob.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
        end
    end)

    sliderKnob.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local mouseX = input.Position.X
            local barPos = sliderBar.AbsolutePosition
            local barSize = sliderBar.AbsoluteSize
            local relativeX = math.clamp(mouseX - barPos.X, 0, barSize.X)
            local value = min + (relativeX / barSize.X) * (max - min)
            currentValue = math.floor(value + 0.5)
            sliderFill.Size = UDim2.new(relativeX / barSize.X, 0, 1, 0)
            sliderKnob.Position = UDim2.new(relativeX / barSize.X, -10, 0.5, -10)
            valueLabel.Text = tostring(currentValue)
            callback(currentValue)
        end
    end)

    -- Set default value
    local defaultRatio = (default - min) / (max - min)
    sliderFill.Size = UDim2.new(defaultRatio, 0, 1, 0)
    sliderKnob.Position = UDim2.new(defaultRatio, -10, 0.5, -10)
    valueLabel.Text = tostring(default)

    return sliderFrame
end

local function createDropdown(parent, text, list, callback)
    local dropdownFrame = Instance.new("Frame")
    dropdownFrame.Size = UDim2.new(1, 0, 0, 30)
    dropdownFrame.BackgroundTransparency = 1
    dropdownFrame.Parent = parent

    local dropdownLabel = Instance.new("TextLabel")
    dropdownLabel.Size = UDim2.new(0.8, 0, 1, 0)
    dropdownLabel.BackgroundTransparency = 1
    dropdownLabel.Text = text
    dropdownLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    dropdownLabel.Font = Enum.Font.Gotham
    dropdownLabel.TextSize = 12
    dropdownLabel.TextXAlignment = Enum.TextXAlignment.Left
    dropdownLabel.Parent = dropdownFrame

    local dropdownButton = Instance.new("TextButton")
    dropdownButton.Size = UDim2.new(0, 100, 0, 20)
    dropdownButton.Position = UDim2.new(0.85, 0, 0.5, -10)
    dropdownButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    dropdownButton.Text = list[1] or ""
    dropdownButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    dropdownButton.Font = Enum.Font.Gotham
    dropdownButton.TextSize = 12
    dropdownButton.Parent = dropdownFrame
    local dropdownButtonCorner = Instance.new("UICorner")
    dropdownButtonCorner.CornerRadius = UDim.new(0, 8)
    dropdownButtonCorner.Parent = dropdownButton
    local dropdownButtonStroke = Instance.new("UIStroke")
    dropdownButtonStroke.Thickness = 1
    dropdownButtonStroke.Color = Color3.fromRGB(255, 255, 255)
    dropdownButtonStroke.Parent = dropdownButton

    local dropdownMenu = Instance.new("Frame")
    dropdownMenu.Size = UDim2.new(0, 100, 0, #list * 25)
    dropdownMenu.Position = UDim2.new(0.85, 0, 0.5, 10)
    dropdownMenu.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    dropdownMenu.BackgroundTransparency = 0.8
    dropdownMenu.Visible = false
    dropdownMenu.Parent = dropdownFrame
    local dropdownMenuCorner = Instance.new("UICorner")
    dropdownMenuCorner.CornerRadius = UDim.new(0, 8)
    dropdownMenuCorner.Parent = dropdownMenu
    local dropdownMenuStroke = Instance.new("UIStroke")
    dropdownMenuStroke.Thickness = 1
    dropdownMenuStroke.Color = Color3.fromRGB(255, 255, 255)
    dropdownMenuStroke.Parent = dropdownMenu

    local dropdownListLayout = Instance.new("UIListLayout")
    dropdownListLayout.Padding = UDim.new(0, 2)
    dropdownListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    dropdownListLayout.Parent = dropdownMenu

    local dropdownItems = {}
    for i, item in ipairs(list) do
        local itemButton = Instance.new("TextButton")
        itemButton.Size = UDim2.new(1, 0, 0, 20)
        itemButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        itemButton.Text = item
        itemButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        itemButton.Font = Enum.Font.Gotham
        itemButton.TextSize = 12
        itemButton.Parent = dropdownMenu
        local itemButtonCorner = Instance.new("UICorner")
        itemButtonCorner.CornerRadius = UDim.new(0, 8)
        itemButtonCorner.Parent = itemButton
        itemButton.MouseButton1Click:Connect(function()
            dropdownButton.Text = item
            dropdownMenu.Visible = false
            callback(item)
        end)
        dropdownItems[item] = itemButton
    end

    dropdownButton.MouseButton1Click:Connect(function()
        dropdownMenu.Visible = not dropdownMenu.Visible
    end)

    return dropdownFrame
end

local function createButton(parent, text, callback)
    local buttonFrame = Instance.new("Frame")
    buttonFrame.Size = UDim2.new(1, 0, 0, 30)
    buttonFrame.BackgroundTransparency = 1
    buttonFrame.Parent = parent

    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0, 100, 0, 25)
    button.Position = UDim2.new(0.85, -100, 0.5, -12.5)
    button.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    button.BackgroundTransparency = 0.8
    button.Text = text
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.Font = Enum.Font.Gotham
    button.TextSize = 12
    button.Parent = buttonFrame
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 8)
    buttonCorner.Parent = button
    local buttonStroke = Instance.new("UIStroke")
    buttonStroke.Thickness = 1
    buttonStroke.Color = Color3.fromRGB(255, 255, 255)
    buttonStroke.Parent = button

    button.MouseButton1Click:Connect(function()
        callback()
    end)

    return buttonFrame
end

-- Tab Content Population
local scrollingFrameBlatant = Instance.new("ScrollingFrame")
scrollingFrameBlatant.Size = UDim2.new(1, 0, 1, 0)
scrollingFrameBlatant.BackgroundTransparency = 1
scrollingFrameBlatant.ScrollBarThickness = 6
scrollingFrameBlatant.CanvasSize = UDim2.new(0, 0, 0, 600)
scrollingFrameBlatant.Parent = tabFrames["Blatant"]
local uiListLayoutBlatant = Instance.new("UIListLayout")
uiListLayoutBlatant.Padding = UDim.new(0, 5)
uiListLayoutBlatant.SortOrder = Enum.SortOrder.LayoutOrder
uiListLayoutBlatant.Parent = scrollingFrameBlatant

local scrollingFramePlayer = Instance.new("ScrollingFrame")
scrollingFramePlayer.Size = UDim2.new(1, 0, 1, 0)
scrollingFramePlayer.BackgroundTransparency = 1
scrollingFramePlayer.ScrollBarThickness = 6
scrollingFramePlayer.CanvasSize = UDim2.new(0, 0, 0, 400)
scrollingFramePlayer.Parent = tabFrames["Player"]
local uiListLayoutPlayer = Instance.new("UIListLayout")
uiListLayoutPlayer.Padding = UDim.new(0, 5)
uiListLayoutPlayer.SortOrder = Enum.SortOrder.LayoutOrder
uiListLayoutPlayer.Parent = scrollingFramePlayer

local scrollingFrameVisuals = Instance.new("ScrollingFrame")
scrollingFrameVisuals.Size = UDim2.new(1, 0, 1, 0)
scrollingFrameVisuals.BackgroundTransparency = 1
scrollingFrameVisuals.ScrollBarThickness = 6
scrollingFrameVisuals.CanvasSize = UDim2.new(0, 0, 0, 600)
scrollingFrameVisuals.Parent = tabFrames["Visuals"]
local uiListLayoutVisuals = Instance.new("UIListLayout")
uiListLayoutVisuals.Padding = UDim.new(0, 5)
uiListLayoutVisuals.SortOrder = Enum.SortOrder.LayoutOrder
uiListLayoutVisuals.Parent = scrollingFrameVisuals

local scrollingFrameMisc = Instance.new("ScrollingFrame")
scrollingFrameMisc.Size = UDim2.new(1, 0, 1, 0)
scrollingFrameMisc.BackgroundTransparency = 1
scrollingFrameMisc.ScrollBarThickness = 6
scrollingFrameMisc.CanvasSize = UDim2.new(0, 0, 0, 400)
scrollingFrameMisc.Parent = tabFrames["Misc"]
local uiListLayoutMisc = Instance.new("UIListLayout")
uiListLayoutMisc.Padding = UDim.new(0, 5)
uiListLayoutMisc.SortOrder = Enum.SortOrder.LayoutOrder
uiListLayoutMisc.Parent = scrollingFrameMisc

local scrollingFrameCredits = Instance.new("ScrollingFrame")
scrollingFrameCredits.Size = UDim2.new(1, 0, 1, 0)
scrollingFrameCredits.BackgroundTransparency = 1
scrollingFrameCredits.ScrollBarThickness = 6
scrollingFrameCredits.CanvasSize = UDim2.new(0, 0, 0, 200)
scrollingFrameCredits.Parent = tabFrames["Credits"]
local uiListLayoutCredits = Instance.new("UIListLayout")
uiListLayoutCredits.Padding = UDim.new(0, 5)
uiListLayoutCredits.SortOrder = Enum.SortOrder.LayoutOrder
uiListLayoutCredits.Parent = scrollingFrameCredits

-- Blatant Tab
local blatantSection = createSection(scrollingFrameBlatant, "Auto Parry")
createToggle(blatantSection, "Auto Parry", function(state)
    AutoParry = state
end, "AutoParry")
createToggle(blatantSection, "Auto Ability", function(state)
    if state then
        local connection
        connection = RunService.Heartbeat:Connect(function()
            if not state then
                connection:Disconnect()
                return
            end
            AutoAbility()
        end)
    end
end, "AutoAbility")
createToggle(blatantSection, "Ball Pause", function(state)
    BallPauseEnabled = state
    if state then
        local connection
        connection = RunService.Heartbeat:Connect(function()
            if not BallPauseEnabled then
                connection:Disconnect()
                return
            end
            pauseBall()
        end)
    end
end, "BallPause")
createSlider(blatantSection, "Ball Pause Distance", 5, 20, 10, function(value)
    BallPauseDistanceThreshold = value
end)
createDropdown(blatantSection, "Parry Type", {"Camera", "Backwards", "Straight", "Random", "High", "Left", "Right", "RandomTarget"}, function(value)
    Selected_Parry_Type = value
end)
createSlider(blatantSection, "Parry Threshold", 1, 5, 2.5, function(value)
    ParryThreshold = value
end)
createDropdown(blatantSection, "First Parry Type", {"F_Key", "Left_Click", "Navigation"}, function(value)
    firstParryType = value
end)
createToggle(blatantSection, "Infinity", function(state)
    Infinity = state
end, "Infinity")

-- Player Tab
local playerSection = createSection(scrollingFramePlayer, "Movement")
createSlider(playerSection, "Strafe Speed", 20, 100, 36, function(value)
    StrafeSpeed = value
end)
createToggle(playerSection, "Phantom", function(state)
    Phantom = state
end, "Phantom")

-- Visuals Tab
local visualsSection = createSection(scrollingFrameVisuals, "ESP")
createToggle(visualsSection, "ESP", function(state)
    espEnabled = state
    if state then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local highlight = Instance.new("Highlight")
                highlight.FillColor = Color3.fromRGB(255, 0, 0)
                highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
                highlight.Parent = player.Character
                espConnections[player] = highlight
            end
        end
    else
        for _, highlight in pairs(espConnections) do
            highlight:Destroy()
        end
        espConnections = {}
    end
end, "ESP")
createToggle(visualsSection, "Name Tags", function(state)
    nameTagsEnabled = state
    if state then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local billboard = Instance.new("BillboardGui")
                billboard.Size = UDim2.new(0, 200, 0, 50)
                billboard.Adornee = player.Character:FindFirstChild("Head")
                billboard.StudsOffset = Vector3.new(0, 2, 0)
                billboard.Parent = player.Character
                local nameLabel = Instance.new("TextLabel")
                nameLabel.Size = UDim2.new(1, 0, 1, 0)
                nameLabel.BackgroundTransparency = 1
                nameLabel.Text = player.Name
                nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
                nameLabel.Font = Enum.Font.Gotham
                nameLabel.TextSize = 14
                nameLabel.Parent = billboard
                nameTagsConnections[player] = billboard
            end
        end
    else
        for _, billboard in pairs(nameTagsConnections) do
            billboard:Destroy()
        end
        nameTagsConnections = {}
    end
end, "NameTags")
createToggle(visualsSection, "Chams", function(state)
    chamsEnabled = state
    if state then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                for _, part in pairs(player.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        local highlight = Instance.new("BoxHandleAdornment")
                        highlight.Size = part.Size
                        highlight.Adornee = part
                        highlight.Color3 = Color3.fromRGB(255, 0, 0)
                        highlight.Transparency = 0.5
                        highlight.Parent = part
                        chamsConnections[part] = highlight
                    end
                end
            end
        end
    else
        for _, highlight in pairs(chamsConnections) do
            highlight:Destroy()
        end
        chamsConnections = {}
    end
end, "Chams")
createToggle(visualsSection, "Fullbright", function(state)
    fullbrightEnabled = state
    if state then
        Lighting.Brightness = 2
        Lighting.Ambient = Color3.fromRGB(255, 255, 255)
        Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
        Lighting.FogEnd = 100000
    else
        Lighting.Brightness = originalLighting.Brightness
        Lighting.Ambient = originalLighting.Ambient
        Lighting.OutdoorAmbient = originalLighting.OutdoorAmbient
        Lighting.FogEnd = originalLighting.FogEnd
    end
end, "Fullbright")
createToggle(visualsSection, "Crosshair", function(state)
    crosshairEnabled = state
    if state then
        crosshairGui = Instance.new("ScreenGui")
        crosshairGui.Parent = CoreGui
        local crosshair = Instance.new("Frame")
        crosshair.Size = UDim2.new(0, 20, 0, 2)
        crosshair.Position = UDim2.new(0.5, -10, 0.5, -1)
        crosshair.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        crosshair.Parent = crosshairGui
        local crosshair2 = Instance.new("Frame")
        crosshair2.Size = UDim2.new(0, 2, 0, 20)
        crosshair2.Position = UDim2.new(0.5, -1, 0.5, -10)
        crosshair2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        crosshair2.Parent = crosshairGui
    else
        if crosshairGui then
            crosshairGui:Destroy()
            crosshairGui = nil
        end
    end
end, "Crosshair")
createDropdown(visualsSection, "Skybox", {"None", "Midnight", "Space", "Galaxy", "Christmas"}, function(value)
    if value == "None" then
        if currentSkybox then
            currentSkybox:Destroy()
            currentSkybox = nil
        end
    else
        applySkybox(value)
    end
end)
createDropdown(visualsSection, "Shader", {"None", "Mid Purple Day", "Mid Pink Day", "Mid Day", "Evening", "Night"}, function(value)
    if value == "None" then
        if currentShader then
            currentShader:Destroy()
            currentShader = nil
        end
    else
        applyShader(value)
    end
end)

-- Misc Tab
local miscSection = createSection(scrollingFrameMisc, "Miscellaneous")
createToggle(miscSection, "Hit Sound", function(state)
    hit_Sound_Enabled = state
end, "HitSound")
createToggle(miscSection, "Cosmetics", function(state)
    CosmeticsActive = state
end, "Cosmetics")
createDropdown(miscSection, "Emotes", Emotes_Data, function(value)
    Auto_Parry.Play_Animation(value)
end)
createButton(miscSection, "Play Music", function()
    -- Placeholder for music input (requires additional UI for ID input)
    playMusic("1234567890") -- Example ID, replace with user input
end)
createButton(miscSection, "Pause Music", function()
    pauseMusic()
end)

-- Credits Tab
local creditsSection = createSection(scrollingFrameCredits, "Credits")
local creditsLabel = Instance.new("TextLabel")
creditsLabel.Size = UDim2.new(1, 0, 0, 100)
creditsLabel.BackgroundTransparency = 1
creditsLabel.Text = "UI Design: Custom\nScript: Adapted from Original\nThanks to xAI for support"
creditsLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
creditsLabel.Font = Enum.Font.Gotham
creditsLabel.TextSize = 12
creditsLabel.TextWrapped = true
creditsLabel.Parent = creditsSection

-- Auto Parry Logic (from provided code)
local function AutoParryLoop()
    while AutoParry do
        local Ball = Auto_Parry.Get_Ball()
        if not Ball or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            task.wait()
            continue
        end

        local Ball_Velocity = Ball.AssemblyLinearVelocity
        local Ball_Speed = Ball_Velocity.Magnitude
        local Ball_Direction = (LocalPlayer.Character.HumanoidRootPart.Position - Ball.Position).Unit
        local Ball_Distance = (LocalPlayer.Character.HumanoidRootPart.Position - Ball.Position).Magnitude
        local Ball_Dot = Ball_Direction:Dot(Ball_Velocity.Unit)
        local Ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue() / 1000
        local Reach_Time = Ball_Distance / Ball_Speed - Ping

        if Ball_Distance < ParryThreshold and Ball_Dot > 0.5 and Reach_Time < 0.1 then
            if Auto_Parry.Parry() then
                Auto_Parry.Parry_Animation()
                Parried = true
                Last_Parry = tick()
            end
        end

        task.wait()
    end
end

-- Start Auto Parry if enabled
if AutoParry then
    task.spawn(AutoParryLoop)
end

-- Handle ESP Connections for New Players
Players.PlayerAdded:Connect(function(player)
    if espEnabled and player ~= LocalPlayer and player.Character then
        local highlight = Instance.new("Highlight")
        highlight.FillColor = Color3.fromRGB(255, 0, 0)
        highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
        highlight.Parent = player.Character
        espConnections[player] = highlight
    end
    if nameTagsEnabled and player ~= LocalPlayer and player.Character then
        local billboard = Instance.new("BillboardGui")
        billboard.Size = UDim2.new(0, 200, 0, 50)
        billboard.Adornee = player.Character:FindFirstChild("Head")
        billboard.StudsOffset = Vector3.new(0, 2, 0)
        billboard.Parent = player.Character
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Size = UDim2.new(1, 0, 1, 0)
        nameLabel.BackgroundTransparency = 1
        nameLabel.Text = player.Name
        nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        nameLabel.Font = Enum.Font.Gotham
        nameLabel.TextSize = 14
        nameLabel.Parent = billboard
        nameTagsConnections[player] = billboard
    end
    if chamsEnabled and player ~= LocalPlayer and player.Character then
        for _, part in pairs(player.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                local highlight = Instance.new("BoxHandleAdornment")
                highlight.Size = part.Size
                highlight.Adornee = part
                highlight.Color3 = Color3.fromRGB(255, 0, 0)
                highlight.Transparency = 0.5
                highlight.Parent = part
                chamsConnections[part] = highlight
            end
        end
    end
end)

-- Cleanup on Player Removal
Players.PlayerRemoving:Connect(function(player)
    if espConnections[player] then
        espConnections[player]:Destroy()
        espConnections[player] = nil
    end
    if nameTagsConnections[player] then
        nameTagsConnections[player]:Destroy()
        nameTagsConnections[player] = nil
    end
end)

-- Update Canvas Size Dynamically
local function updateCanvasSize(scrollingFrame, layout)
    layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 10)
    end)
end

updateCanvasSize(scrollingFrameBlatant, uiListLayoutBlatant)
updateCanvasSize(scrollingFramePlayer, uiListLayoutPlayer)
updateCanvasSize(scrollingFrameVisuals, uiListLayoutVisuals)
updateCanvasSize(scrollingFrameMisc, uiListLayoutMisc)
updateCanvasSize(scrollingFrameCredits, uiListLayoutCredits)

-- Handle Last Input Type
UserInputService.LastInputTypeChanged:Connect(function(inputType)
    Last_Input = inputType
end)

-- Ensure UI Persists
screenGui.AncestryChanged:Connect(function()
    if screenGui.Parent ~= CoreGui then
        screenGui.Parent = CoreGui
    end
end)
